LAST_LOG_CURSOR: 2026-02-05T16:22:10+09:00

---

## 세션: 2026-02-05 (LAST_LOG_CURSOR 이후)

---

### 사용자:

너는 지금부터 '포인트 룰렛' 서비스의 Planner야.
my--claude-code-asset에 정의된 Planner Agent 역할을 수행해.
아래 요구사항을 기준으로 /ccpp:plan을 사용해.
출력은 Server Plan 문서 형태로 출력해. 아직 claude.md는 만들지 마.

[INPUT FOR ccpp:plan]

아래는 과제에서 제공된 원문 요구사항이다.
요구사항은 일부 모호하거나 정책이 열려 있을 수 있다.

Planner Agent의 역할:
- 요구사항을 그대로 구현하지 말고
- 서비스 관점에서 재해석/재구성할 것
- 모호한 부분은 '정책 결정 포인트'로 분리하고 추천안을 제시할 것
- 동시성/정합성/운영 관점의 숨은 요구를 끌어낼 것

중요 제약:
- 요구사항에 없는 기능을 임의로 추가하지 말 것
- 단, 요구사항을 만족하기 위해 **암묵적으로 필요한 정책/규칙은 명시화할 것**
- 지금 단계에서는 코드/DB 스키마를 작성하지 말 것

매일 룰렛을 돌려 포인트를 획득하고, 획득한 포인트로 상품을 구매하는 서비스입니다.

### 핵심 특징
- **일일 예산 관리**: 하루 총 100,000p 예산, 소진 시 당첨 불가
- **1일 1회 참여**: 유저별 하루에 한 번만 룰렛 참여 가능
- **랜덤 포인트**: 100p ~ 1,000p 범위에서 랜덤 지급
- **포인트 유효기간**: 획득일로부터 **30일** (만료된 포인트는 사용 불가)
- **상품 구매**: 획득한 포인트로 상품 구매

### 시나리오
1. 유저 A가 로그인 Mocking으로 접속
2. 룰렛 참여 → 350p 당첨 (오늘 잔여 예산: 99,650p)
3. 유저 A 재참여 시도 → "오늘 이미 참여했습니다" 거절
4. 유저 B~Z가 차례로 참여하며 예산 소진
5. 예산 소진 후 유저 참여 → "오늘 예산이 소진되었습니다" (꽝)
6. 유저 A가 획득한 포인트로 상품 구매

## 1. 백엔드 (Spring Boot + Kotlin)

**기술 스택**: Spring Boot 3.x + Kotlin, JPA, Swagger, H2/MySQL/PostgreSQL 택1

### 구현해야 할 기능

아래 기능들을 구현하는 API를 직접 설계하세요.

**인증**
- 로그인 (닉네임이나 아이디만 입력하는 간단한 방식)

**어드민 기능**
- 일일 예산 조회/설정
- 상품 CRUD (목록, 등록, 수정)
- 주문 취소 (포인트 환불)
- 룰렛 참여 취소 (포인트 회수)

**사용자 기능**
- 룰렛 참여 (1일 1회, 100~1000p 랜덤)
- 오늘 참여 여부 및 잔여 예산 확인
- 내 포인트 조회 (유효기간 포함) / 잔액 조회
- 상품 목록 조회
- 상품 주문 (포인트 차감)
- 주문 내역 조회

### 핵심 로직

이 서비스의 핵심은 **"하루 한정된 예산"** 과 **"1일 1회 참여"** 라는 제약 조건을 수많은 유저가 동시에 몰리는 상황에서도 정확하게 지키는 것입니다.

1. **중복 참여 방지**: 같은 유저가 동시에 두 번 요청할 때, 한 번만 성공해야 합니다.
2. **예산 소진 처리**: 예산이 1,000p 남았는데 5명이 동시에 500p씩 당첨되려 한다면, 정확히 예산 범위 내에서만 지급되어야 합니다.

### 필수 기능
- 로그인 Mocking (닉네임만 입력)
- 룰렛 참여 (1일 1회, 100~1000p 랜덤)
- 일일 예산 초과 방지
- 포인트 유효기간 관리 (획득일 + 30일)
- 만료 예정 포인트 조회 (7일 이내 만료)
- 상품 CRUD (어드민)
- 상품 구매 (포인트 차감)
- API 문서화 (Swagger)

---

## 2. 웹 어드민 (React)

**기술 스택**: React 18+ (Vite), TypeScript, UI 라이브러리 자유 (shadcn/ui, Ant Design 등 권장)

| 화면 | 기능 |
|------|------|
| **대시보드** | 오늘 예산 현황, 참여자 수, 지급 포인트 |
| **예산 관리** | 일일 예산 설정/조회, **룰렛 참여 취소(포인트 회수)** 기능 |
| **상품 관리** | 상품 CRUD, 재고 관리 |
| **주문 내역** | 주문 목록, 상태 변경, **주문 취소(포인트 환불)** 기능 |

**필수 기능**: 테이블 목록, CRUD 폼, API 연동

> **평가 기준**: 어드민은 **기능 동작 여부** 중심으로 평가합니다. UI 디자인보다 기능 구현에 집중하세요.

---

## 3. 웹 프론트엔드 (사용자 앱용)

**기술 스택**: Next.js 14+ 또는 React 18+ (Vite), TypeScript, Tailwind, TanStack Query

| 화면 | 기능 |
|------|------|
| **로그인** | 닉네임 입력 (로그인 Mocking) |
| **홈 (룰렛)** | 룰렛 UI, 오늘 잔여 예산 표시 |
| **내 포인트** | 포인트 목록 (유효기간, **만료됨** 상태 표시), **7일 내 만료 예정 포인트** 알림 |
| **상품 목록** | 구매 가능 상품, 내 포인트로 구매 가능 여부 |
| **주문 내역** | 내 주문 목록 |

**필수 기능**: 룰렛 애니메이션, API 연동, 로딩/에러 처리

> **평가 기준**: UI 디자인은 최소한만 구현하세요. **기능이 정상 동작하는지** 중심으로 평가합니다.
---


## 4. Flutter 앱 (WebView)

### 필수 구현
- 웹 프론트엔드를 WebView로 렌더링
- iOS/Android 동작, 뒤로가기 처리
- 로그인 상태 유지

### 추가 구현 (가산점)
- **앱 아이콘 & 이름 변경**: 기본 Flutter 아이콘/이름 대신, 서비스에 맞는 것으로 변경
- **네트워크 에러 처리**: 인터넷 연결 끊김이나 페이지 로딩 실패 시 **커스텀 에러 페이지** 표시 및 '재시도' 버튼 구현
- **로딩 처리**: WebView 로딩 중 **네이티브 인디케이터(Spinner)** 표시
- **스플래시 스크린(Splash Screen)**: 앱 실행 시 네이티브 스플래시 화면 적용

---

## 5. 배포

호스팅이 가능한 서비스라면 어떤 것이든 사용 가능합니다.

**추천 무료 서비스:**
- **프론트엔드/어드민**: [Vercel](https://vercel.com)
- **백엔드**: [Render](https://render.com), [Railway](https://railway.app)
- **데이터베이스**: [Neon](https://neon.tech) (서버리스 PostgreSQL)

**제출 항목:**
- 프론트엔드 접속 URL
- 어드민 접속 URL
- 백엔드 API 문서 (`/swagger-ui` 또는 `/api-docs`)
- Flutter 앱 APK 파일

### CI/CD 파이프라인 (필수: 백엔드만)
- **GitHub Actions** 또는 **Jenkins**를 사용하여 **백엔드** 자동 배포 파이프라인을 구축하세요.
- 코드를 Push했을 때 빌드 및 테스트가 자동으로 실행되어야 합니다.
- **설정 파일**(`ci.yml` 또는 `Jenkinsfile` 등)이 저장소에 포함되어야 합니다.

> **참고**: 프론트엔드/어드민은 Vercel GitHub 연동 자동 배포로 충분합니다.

---

### Claude 응답:

# Server Plan: 포인트 룰렛 서비스

---

## 1. 요구사항 재해석

### 1.1 서비스 본질

이 서비스는 **"제한된 자원(일일 예산)을 다수의 사용자가 경쟁적으로 소비하는 시스템"**입니다. 핵심 난이도는 UI가 아니라 **동시성 환경에서의 정합성 보장**에 있습니다.

| 원문 요구 | 서비스 관점 재해석 |
|---|---|
| 1일 1회 참여 | **유저별 일일 참여 제한** — (userId, date) 유니크 제약으로 DB 레벨에서 강제. 프론트 체크는 UX용일 뿐, 진실의 원천은 DB |
| 일일 예산 100,000p | **공유 자원의 원자적 차감** — race condition 발생 지점. 조건부 UPDATE(`remaining >= amount`)로만 차감 |
| 100~1,000p 랜덤 | **당첨 금액 결정 시점**이 중요. 예산 잔여 < 당첨 금액이면 지급 실패 처리 |
| 포인트 유효기간 30일 | **만료 포인트는 사용 불가** — 주문 시 만료 여부를 실시간 검증. 잔액 조회도 유효 포인트만 집계 |
| 상품 구매 | **포인트 차감 + 주문 생성**의 원자적 처리. 포인트 부족/만료 시 결제 실패 |
| 로그인 Mocking | 실제 인증 없이 **닉네임/아이디만으로 세션 식별**. 단, 유저 식별은 고유해야 함 |

### 1.2 암묵적 요구사항 (원문에 없지만 필수)

| 숨은 요구 | 이유 |
|---|---|
| 예산 리셋 정책 | 매일 자정(KST)에 예산이 자동 리셋되어야 룰렛이 다시 돌아감. 스케줄러 or 요청 시 날짜 비교 방식 필요 |
| 포인트 만료 처리 시점 | 만료 포인트를 배치로 상태 변경할지, 조회/사용 시점에 동적으로 필터할지 결정 필요 |
| 포인트 차감 순서(FIFO) | 주문 시 어떤 포인트부터 차감할지. 유효기간 임박 순(FIFO)이 합리적 |
| 주문 취소 시 환불 포인트의 유효기간 | 원래 포인트의 잔여 유효기간을 복원할지, 새 유효기간을 부여할지 |
| 룰렛 취소 시 예산 복구 여부 | 회수한 포인트만큼 일일 예산을 다시 증가시킬지 |
| 상품 재고 관리 | 요구사항에 "재고 관리" 언급 있음. 재고 0인 상품은 구매 불가 처리 필요 |
| 어드민 vs 사용자 권한 분리 | Mocking 인증이지만, 어드민 API는 일반 유저가 호출 불가해야 함 |
| '하루'의 경계 시점 | KST 00:00:00 기준. 서버 타임존과 무관하게 KST 고정 |

---

## 2. 정책 결정 포인트 (PDP)

아래는 요구사항이 모호하거나 열려 있어 **구현 전 확정이 필요한 항목**입니다. 각 항목에 추천안을 제시합니다.

### PDP-1: 예산 리셋 방식

| 선택지 | 설명 |
|---|---|
| **A. Lazy 리셋 (추천)** | 예산 테이블에 `budget_date`를 저장. 룰렛 요청 시 오늘(KST) 날짜와 비교하여, 날짜가 다르면 `remaining = daily_limit`으로 리셋 |
| B. 스케줄러 리셋 | @Scheduled로 매일 KST 00:00에 리셋. 서버 다운 시 리셋 누락 가능성 |

**추천: A** — 스케줄러 의존성 없이, 요청 시점에 자연스럽게 리셋. 무료 배포 환경에서 서버 sleep 문제도 회피.

### PDP-2: 포인트 만료 처리 방식

| 선택지 | 설명 |
|---|---|
| **A. 조회/사용 시 동적 필터 (추천)** | 포인트 레코드에 `expires_at` 저장. 잔액 조회/주문 시 `WHERE expires_at > NOW()` 조건으로 유효분만 사용 |
| B. 배치 상태 변경 | 매일 스케줄러로 만료 포인트의 상태를 EXPIRED로 변경 |

**추천: A** — 실시간 정확성 보장. 배치 지연으로 인한 만료 포인트 사용 방지. 단, 목록 조회 시 상태 표시를 위해 `expires_at < NOW()`인 경우 "만료됨" 레이블 표시.

### PDP-3: 주문 시 포인트 차감 순서

| 선택지 | 설명 |
|---|---|
| **A. 만료 임박 순(FIFO) (추천)** | `expires_at ASC` 순서로 유효 포인트부터 차감 |
| B. 최신 획득 순(LIFO) | 최근 포인트부터 차감 |

**추천: A** — 소멸 직전 포인트를 먼저 소진하여 유저 이익 극대화. 서비스 관점에서도 자연스러움.

### PDP-4: 주문 취소 시 환불 포인트의 유효기간

| 선택지 | 설명 |
|---|---|
| **A. 원래 포인트의 잔여 유효기간 복원 (추천)** | 차감했던 포인트 레코드를 복원(잔액 되돌림). 이미 만료된 포인트는 복원 불가 → 실질적 손실 발생 가능 |
| B. 새 유효기간 부여 (취소일 + 30일) | 환불 시 새 포인트 레코드 생성 |
| C. 원래 유효기간 복원, 만료분도 복원 | 유저 유리하지만 만료 정책의 의미가 약해짐 |

**추천: A** — 가장 직관적이고 정합성 유지가 쉬움. "원래 포인트를 되돌린다"는 개념. 만료된 부분은 환불 불가라는 정책을 명시하면 됨.

### PDP-5: 룰렛 취소 시 예산 복구 여부

| 선택지 | 설명 |
|---|---|
| **A. 당일만 복구 (추천)** | 취소 당일이 지급일과 같은 날이면 예산 복구. 다른 날이면 복구하지 않음 |
| B. 항상 복구 | 지급일과 무관하게 예산 복구 → 과거 예산을 소급 변경하는 셈이라 복잡 |
| C. 복구하지 않음 | 단순하지만, 취소해도 예산이 줄어든 상태 유지 |

**추천: A** — 당일 취소만 예산 복구. 과거 날짜의 예산은 이미 닫힌 것으로 간주하여 복잡성 최소화.

### PDP-6: 예산 잔여 < 당첨 금액일 때 처리

| 선택지 | 설명 |
|---|---|
| **A. 잔여 예산이 100p 미만이면 소진 처리 (추천)** | 최소 당첨금(100p) 미만이면 사실상 지급 불가. "예산 소진" 응답 |
| B. 잔여 예산만큼 지급 | 예산 50p 남으면 50p 지급 → 최소 100p 규칙 위반 |
| C. 당첨 금액을 잔여 범위로 클램핑 | 잔여 500p면 100~500p 범위로 랜덤 → 구현 가능하나 복잡 |

**추천: A** — 당첨 금액은 항상 100~1,000p를 보장하되, 먼저 랜덤 금액을 결정한 후 `remaining >= amount` 조건으로 차감 시도. 실패 시 "예산 소진" 처리. 단, 잔여가 100p 이상이면 `min(잔여, 1000)` 범위에서 랜덤 결정하여 성공 확률을 높이는 것도 고려 가능.

### PDP-7: 로그인 Mocking의 유저 식별 방식

| 선택지 | 설명 |
|---|---|
| **A. 닉네임 = 유저 ID (추천)** | 닉네임을 입력하면 해당 닉네임의 유저가 없으면 자동 생성, 있으면 로그인. 별도 회원가입 없음 |
| B. 별도 ID + 닉네임 | 회원가입/로그인 분리 → Mocking 취지에 맞지 않음 |

**추천: A** — 최소 마찰 로그인. 닉네임이 곧 식별자. 유니크 제약 적용.

### PDP-8: 어드민 인증 방식

| 선택지 | 설명 |
|---|---|
| **A. 하드코딩 어드민 계정 + 별도 엔드포인트 (추천)** | `/api/admin/**` 경로에 간단한 인증(예: 환경변수 기반 비밀번호) 적용 |
| B. 역할 기반 (ROLE_ADMIN) | 유저 테이블에 role 필드 → Mocking 인증과 조합하면 과도 |

**추천: A** — 어드민 API는 별도 경로로 분리하고, 간단한 인증(Basic Auth 또는 환경변수 비밀번호)으로 보호. 사용자 API와 완전 분리.

---

## 3. 도메인 모델 설계 (개념 수준)

### 3.1 핵심 엔티티

```
User
├── id (PK)
├── nickname (UNIQUE)
└── created_at

DailyBudget
├── id (PK)
├── budget_date (UNIQUE) — KST 기준 날짜
├── daily_limit — 기본 100,000
├── remaining — 잔여 예산 (원자적 차감 대상)
└── updated_at

RouletteHistory
├── id (PK)
├── user_id (FK)
├── spin_date — KST 기준 날짜
├── amount — 당첨 금액
├── status — ACTIVE / CANCELLED
├── created_at
└── UNIQUE(user_id, spin_date) — 1일 1회 보장

PointLedger (포인트 원장)
├── id (PK)
├── user_id (FK)
├── roulette_history_id (FK, nullable)
├── amount — 원래 지급 금액
├── balance — 잔여 사용 가능 금액
├── type — EARN / REFUND
├── issued_at
├── expires_at — issued_at + 30일
└── created_at

Product
├── id (PK)
├── name
├── description
├── price — 포인트 가격
├── stock — 재고 수량
├── status — ACTIVE / INACTIVE
└── created_at / updated_at

Order
├── id (PK)
├── user_id (FK)
├── product_id (FK)
├── total_price
├── status — COMPLETED / CANCELLED
├── created_at
└── cancelled_at

OrderPointUsage (주문-포인트 매핑)
├── id (PK)
├── order_id (FK)
├── point_ledger_id (FK)
└── amount — 해당 포인트에서 차감한 금액
```

### 3.2 엔티티 관계

```
User ──1:N──> RouletteHistory
User ──1:N──> PointLedger
User ──1:N──> Order
Order ──1:N──> OrderPointUsage ──N:1──> PointLedger
RouletteHistory ──1:1──> PointLedger (지급 시)
Product ──1:N──> Order
```

### 3.3 설계 핵심 포인트

- **PointLedger의 balance 필드**: 부분 차감을 지원. 500p 포인트에서 300p 사용 시 balance = 200p. 환불 시 balance 복원.
- **OrderPointUsage**: 하나의 주문에서 여러 포인트 레코드를 FIFO로 차감하므로, 어떤 포인트에서 얼마를 썼는지 추적. 환불 시 역으로 복원.
- **DailyBudget**: 날짜별 1행. Lazy 리셋 시 오늘 행이 없으면 생성 + 기본값 세팅.

---

## 4. 동시성/정합성 전략

### 4.1 중복 참여 방지

```
1. UNIQUE INDEX on (user_id, spin_date)
2. INSERT 시도 → 성공하면 참여 처리, 실패(duplicate)하면 "이미 참여" 응답
3. 또는 SELECT FOR UPDATE 후 INSERT (비관적 락)
```

**추천 방식**: UNIQUE 제약 + INSERT 시도 → DataIntegrityViolationException 캐치 → "이미 참여" 응답. 가장 단순하고 확실.

### 4.2 예산 원자적 차감

```sql
UPDATE daily_budget
SET remaining = remaining - :amount, updated_at = NOW()
WHERE budget_date = :today AND remaining >= :amount
```

영향 행 수 = 0이면 예산 부족. 이 방식은 **별도 락 없이도 원자적**. PostgreSQL의 행 수준 잠금이 자동 적용.

### 4.3 주문 시 포인트 차감

```
1. 유효 포인트를 expires_at ASC 순으로 조회 (SELECT ... FOR UPDATE)
2. FIFO로 balance 차감
3. OrderPointUsage 레코드 생성
4. 총 차감액 < 주문 금액이면 롤백 + "포인트 부족"
```

비관적 락(`SELECT FOR UPDATE`)으로 동시 주문 시 같은 포인트 이중 차감 방지.

### 4.4 트랜잭션 경계

| 작업 | 트랜잭션 범위 |
|---|---|
| 룰렛 참여 | RouletteHistory INSERT + DailyBudget UPDATE + PointLedger INSERT = 하나의 트랜잭션 |
| 상품 주문 | Order INSERT + PointLedger balance UPDATE + OrderPointUsage INSERT + Product stock UPDATE = 하나의 트랜잭션 |
| 주문 취소 | Order 상태 변경 + PointLedger balance 복원 + Product stock 복원 = 하나의 트랜잭션 |
| 룰렛 취소 | RouletteHistory 상태 변경 + PointLedger 상태 변경/삭제 + (당일이면) DailyBudget 복구 = 하나의 트랜잭션 |

---

## 5. API 설계 (개요)

### 5.1 사용자 API (`/api/v1/**`)

| Method | Path | 설명 |
|---|---|---|
| POST | `/auth/login` | 닉네임 로그인 (유저 자동 생성) |
| POST | `/roulette/spin` | 룰렛 참여 |
| GET | `/roulette/status` | 오늘 참여 여부 + 잔여 예산 |
| GET | `/points` | 내 포인트 목록 (유효/만료 구분) |
| GET | `/points/balance` | 사용 가능 잔액 합계 |
| GET | `/points/expiring` | 7일 내 만료 예정 포인트 |
| GET | `/products` | 상품 목록 |
| POST | `/orders` | 상품 주문 |
| GET | `/orders` | 내 주문 내역 |

### 5.2 어드민 API (`/api/admin/**`)

| Method | Path | 설명 |
|---|---|---|
| GET | `/budget` | 오늘 예산 현황 |
| PUT | `/budget` | 일일 예산 설정 |
| GET | `/dashboard` | 대시보드 (오늘 참여자 수, 지급 총액 등) |
| GET | `/products` | 상품 목록 |
| POST | `/products` | 상품 등록 |
| PUT | `/products/{id}` | 상품 수정 |
| GET | `/orders` | 전체 주문 내역 |
| POST | `/orders/{id}/cancel` | 주문 취소 (포인트 환불) |
| GET | `/roulette/history` | 룰렛 참여 내역 |
| POST | `/roulette/{id}/cancel` | 룰렛 참여 취소 (포인트 회수) |

### 5.3 응답 포맷

```json
// 성공
{
  "success": true,
  "data": { ... }
}

// 실패
{
  "success": false,
  "error": {
    "code": "ALREADY_PARTICIPATED",
    "message": "오늘 이미 참여했습니다"
  }
}
```

**에러 코드 목록** (구분 가능하게):
- `ALREADY_PARTICIPATED` — 오늘 이미 참여
- `BUDGET_EXHAUSTED` — 예산 소진
- `INSUFFICIENT_POINTS` — 포인트 부족
- `POINT_EXPIRED` — 만료 포인트만 보유
- `PRODUCT_OUT_OF_STOCK` — 재고 소진
- `ORDER_ALREADY_CANCELLED` — 이미 취소된 주문
- `ROULETTE_ALREADY_CANCELLED` — 이미 취소된 룰렛
- `ROULETTE_POINTS_USED` — 해당 포인트로 주문이 존재하여 룰렛 취소 불가

---

## 6. 숨은 엣지 케이스 & 운영 리스크

### 6.1 룰렛 취소 시 포인트가 이미 사용된 경우

유저 A가 500p 당첨 → 300p로 상품 구매 → 어드민이 룰렛 취소 시도

**처리 방안**:
- 해당 포인트로 주문이 존재하면 룰렛 취소 거부 (에러 코드: `ROULETTE_POINTS_USED`)
- 또는 해당 주문을 먼저 취소한 후 룰렛 취소 가능하도록 안내

### 6.2 예산 설정 변경의 적용 시점

어드민이 예산을 50,000p로 낮출 때, 이미 80,000p를 지급한 상태라면?

**처리 방안**: `daily_limit` 변경은 다음 날부터 적용. 당일 `remaining`은 변경하지 않음. 또는 즉시 적용 시 `remaining = max(0, new_limit - (old_limit - old_remaining))` 계산.

**추천**: 다음 날부터 적용. 단순하고 예측 가능.

### 6.3 자정(KST) 전후 요청

23:59:59에 룰렛 참여 → 서버 처리 중 00:00:01이 됨 → spin_date가 어느 날?

**처리 방안**: 트랜잭션 시작 시점의 KST 날짜를 사용. 요청 시점이 아닌 서버 처리 시점 기준.

### 6.4 주문 취소 후 포인트 만료

500p 포인트로 300p 주문 → 포인트 만료됨 → 주문 취소 요청

**처리 방안** (PDP-4에서 추천한 A안 적용): 원래 포인트 레코드의 balance를 복원하지만, `expires_at`이 이미 지났으므로 복원된 포인트는 사용 불가 상태. 유저에게 "환불되었지만 해당 포인트는 이미 만료되었습니다" 안내.

### 6.5 상품 재고 동시 차감

같은 상품을 여러 유저가 동시에 주문할 때 재고가 음수가 되면 안 됨.

**처리 방안**: `UPDATE product SET stock = stock - 1 WHERE id = :id AND stock > 0` 조건부 업데이트. 예산 차감과 동일한 패턴.

---

## 7. 구현 순서 (Phase 기반)

### Phase 1: 백엔드 코어 (최우선)

```
1-1. 프로젝트 스캐폴딩 (Spring Boot + Kotlin + JPA + PostgreSQL)
1-2. 엔티티 & 마이그레이션
1-3. 로그인 Mocking API
1-4. 룰렛 참여 API (핵심 동시성 로직)
1-5. 포인트 조회 API (잔액, 목록, 만료 예정)
1-6. 상품 CRUD (어드민)
1-7. 상품 주문 API (포인트 차감)
1-8. 주문/룰렛 취소 API (어드민)
1-9. 대시보드 API
1-10. Swagger 문서화
1-11. 단위 테스트 + 동시성 테스트
```

### Phase 2: 백엔드 배포 & CI/CD

```
2-1. Docker Compose (로컬 PostgreSQL)
2-2. Neon DB 설정 (배포용)
2-3. GitHub Actions CI/CD
2-4. Render/Railway 배포
```

### Phase 3: 프론트엔드 (사용자 웹)

```
3-1. 프로젝트 스캐폴딩 (React + Vite + TypeScript + Tailwind + TanStack Query)
3-2. 로그인 화면
3-3. 홈 (룰렛 UI + 애니메이션)
3-4. 내 포인트 화면
3-5. 상품 목록 + 구매
3-6. 주문 내역
3-7. 로딩/에러 처리
```

### Phase 4: 어드민 웹

```
4-1. 프로젝트 스캐폴딩 (별도 앱)
4-2. 대시보드
4-3. 예산 관리 + 룰렛 취소
4-4. 상품 관리 CRUD
4-5. 주문 내역 + 주문 취소
```

### Phase 5: 프론트엔드 & 어드민 배포

```
5-1. Vercel 배포 (프론트엔드)
5-2. Vercel 배포 (어드민)
5-3. 환경변수 설정
```

### Phase 6: 모바일 (Flutter WebView)

```
6-1. Flutter 프로젝트 생성
6-2. WebView 연동
6-3. 뒤로가기 처리
6-4. 로그인 상태 유지
6-5. 추가: 앱 아이콘, 스플래시, 네트워크 에러, 로딩 인디케이터
6-6. APK 빌드
```

---

## 8. 테스트 전략

### 필수 동시성 테스트 시나리오

| # | 시나리오 | 기대 결과 |
|---|---|---|
| T-1 | 동일 유저 10개 동시 룰렛 요청 | 1건만 성공, 9건은 ALREADY_PARTICIPATED |
| T-2 | 100명 동시 룰렛 (예산 100,000p) | 총 지급액 <= 100,000p |
| T-3 | 예산 500p 남은 상태에서 10명 동시 요청 | 최대 5명만 성공 (100p 최소 기준) |
| T-4 | 동일 상품(재고 1) 3명 동시 주문 | 1건만 성공 |
| T-5 | 만료 포인트로 주문 시도 | 실패 (INSUFFICIENT_POINTS) |
| T-6 | 주문 취소 후 포인트 잔액 복원 확인 | balance 정확히 복원 |
| T-7 | 룰렛 취소 시 포인트 사용 중이면 거부 | ROULETTE_POINTS_USED |

---

## 9. 기술 스택 확정

| 레이어 | 스택 |
|---|---|
| Backend | Spring Boot 3.x, Kotlin, JPA (Hibernate), PostgreSQL |
| API 문서 | SpringDoc OpenAPI 3 (Swagger UI) |
| Frontend | React 18+, Vite, TypeScript, Tailwind CSS, TanStack Query |
| Admin | React 18+, Vite, TypeScript, Tailwind CSS, TanStack Query (별도 앱) |
| Mobile | Flutter (WebView), Dart |
| DB (로컬) | Docker Compose + PostgreSQL |
| DB (배포) | Neon (서버리스 PostgreSQL) |
| CI/CD | GitHub Actions (백엔드) |
| 배포 | Render or Railway (백엔드), Vercel (프론트엔드/어드민) |

---

## 10. 정책 결정 요약 (확정 필요)

| # | 항목 | 추천안 | 확정 여부 |
|---|---|---|---|
| PDP-1 | 예산 리셋 방식 | Lazy 리셋 (요청 시 날짜 비교) | **미확정** |
| PDP-2 | 포인트 만료 처리 | 조회/사용 시 동적 필터 | **미확정** |
| PDP-3 | 포인트 차감 순서 | 만료 임박 순 (FIFO) | **미확정** |
| PDP-4 | 환불 포인트 유효기간 | 원래 포인트 복원 (만료분은 복원 불가) | **미확정** |
| PDP-5 | 룰렛 취소 시 예산 복구 | 당일만 복구 | **미확정** |
| PDP-6 | 예산 < 당첨금 처리 | 잔여 100p 미만이면 소진 처리 | **미확정** |
| PDP-7 | 유저 식별 방식 | 닉네임 = 유저 ID (자동 생성) | **미확정** |
| PDP-8 | 어드민 인증 | 별도 경로 + 환경변수 비밀번호 | **미확정** |

---

위 Server Plan에서 **정책 결정 포인트(PDP) 8개 항목**에 대해 확인이 필요합니다. 추천안대로 진행할지, 다른 방향을 원하시는지 알려주시면 SPEC.md 작성 단계로 넘어가겠습니다.

---

### 사용자:

1~7번까지는 승인할게. 그런데 8번에 대해 요구사항 문서에 별도 어드민 인증 절차가 명시되어있지 않으므로, 사용자 앱과 똑같이 로그인 Mocking을 공유하되, 특정 닉네임이면 role=ADMIN을 부여해 접근하는 방안으로 수정해줘. 즉 role 체크만 수행하는 쪽으로 변경해.

---

### Claude 응답:

PDP-8을 아래와 같이 수정합니다.

---

## PDP-8 수정: 어드민 인증 방식

| 항목 | 변경 전 | **변경 후 (확정)** |
|---|---|---|
| 인증 방식 | 별도 경로 + 환경변수 비밀번호 (Basic Auth) | **로그인 Mocking 공유 + role 기반 접근 제어** |

**확정 정책**:
- 사용자 앱과 동일한 닉네임 로그인 Mocking을 사용
- User 엔티티에 `role` 필드 추가 (`USER` / `ADMIN`)
- 특정 닉네임(예: `admin`, 또는 환경변수로 지정한 닉네임 목록)으로 로그인 시 `role = ADMIN` 부여
- `/api/admin/**` 엔드포인트는 `role = ADMIN`인 유저만 접근 가능 (role 체크)
- 일반 유저가 어드민 API 호출 시 `403 Forbidden` 응답

**도메인 모델 반영**:
```
User
├── id (PK)
├── nickname (UNIQUE)
├── role — USER / ADMIN (기본값: USER)
└── created_at
```

**엣지 케이스**:
- 어드민 닉네임 목록은 환경변수(`ADMIN_NICKNAMES=admin,manager`)로 관리하여 하드코딩 방지
- 어드민도 일반 유저 기능(룰렛, 주문 등) 사용 가능 여부 → **가능** (role은 추가 권한일 뿐)

---

## 최종 정책 결정 요약 (전체 확정)

| # | 항목 | 확정안 |
|---|---|---|
| PDP-1 | 예산 리셋 방식 | Lazy 리셋 (요청 시 날짜 비교) |
| PDP-2 | 포인트 만료 처리 | 조회/사용 시 동적 필터 (`expires_at` 기준) |
| PDP-3 | 포인트 차감 순서 | 만료 임박 순 FIFO (`expires_at ASC`) |
| PDP-4 | 환불 포인트 유효기간 | 원래 포인트 복원 (만료분은 복원 불가) |
| PDP-5 | 룰렛 취소 시 예산 복구 | 당일만 복구 |
| PDP-6 | 예산 < 당첨금 처리 | 잔여 100p 미만이면 소진 처리 |
| PDP-7 | 유저 식별 방식 | 닉네임 = 유저 ID (자동 생성) |
| **PDP-8** | **어드민 인증** | **로그인 Mocking 공유 + role(USER/ADMIN) 체크. 어드민 닉네임은 환경변수로 관리** |

---

전체 정책이 확정되었습니다. 다음 단계로 `docs/SPEC.md` 작성으로 넘어갈까요?

---

### 사용자:

정정할게.

우리 서비스는 "같은 앱"이지만 로그인 후 화면/기능이 역할에 따라 완전히 분리돼.
- ADMIN 로그인 → 어드민 전용 UI만 접근 (상품 CRUD, 주문 취소/환불, 룰렛 취소/회수 등)
- USER 로그인 → 유저 UI만 접근 (룰렛 참여, 포인트 조회, 구매 등)

그래서 "어드민도 일반 유저 기능을 사용 가능"은 이번 과제의 의도와 맞지 않아.
role은 단순히 권한 추가가 아니라, '접근 가능한 화면/기능 세트' 자체를 분리하는 기준이야.

문서(clause.md)에서는 아래 정책으로 고쳐줘:
1) ADMIN은 /api/user/** 호출 금지 (403)
2) USER는 /api/admin/** 호출 금지 (403)
3) 로그인 응답에 role 포함, 프론트는 role에 따라 라우팅을 분기

---

### Claude 응답:

PDP-8을 아래와 같이 재수정합니다.

---

## PDP-8 재수정: 역할 기반 완전 분리

| 항목 | 변경 전 | **확정** |
|---|---|---|
| 권한 모델 | 어드민도 유저 기능 사용 가능 (추가 권한) | **역할별 접근 가능 기능 세트가 완전히 분리** |

**확정 정책**:

1. **API 접근 제어** — role에 따라 호출 가능한 API가 완전히 분리
   - `ADMIN` → `/api/admin/**`만 허용, `/api/user/**` 호출 시 `403`
   - `USER` → `/api/user/**`만 허용, `/api/admin/**` 호출 시 `403`
   - `/api/auth/**` (로그인 등)은 role 무관하게 접근 가능

2. **로그인 응답에 role 포함** — 프론트엔드는 role 값으로 라우팅 분기
   ```json
   {
     "success": true,
     "data": {
       "userId": 1,
       "nickname": "admin",
       "role": "ADMIN",
       "token": "..."
     }
   }
   ```

3. **프론트엔드 라우팅** — role에 따라 진입점 자체가 다름
   - `USER` → 룰렛, 포인트, 상품, 주문 화면
   - `ADMIN` → 대시보드, 예산 관리, 상품 CRUD, 주문/룰렛 취소 화면

4. **어드민 닉네임 관리** — 환경변수(`ADMIN_NICKNAMES`)로 지정, 해당 닉네임 로그인 시 `role = ADMIN` 부여

---

## 최종 정책 결정 요약 (전체 확정)

| # | 항목 | 확정안 |
|---|---|---|
| PDP-1 | 예산 리셋 방식 | Lazy 리셋 (요청 시 날짜 비교) |
| PDP-2 | 포인트 만료 처리 | 조회/사용 시 동적 필터 (`expires_at` 기준) |
| PDP-3 | 포인트 차감 순서 | 만료 임박 순 FIFO (`expires_at ASC`) |
| PDP-4 | 환불 포인트 유효기간 | 원래 포인트 복원 (만료분은 복원 불가) |
| PDP-5 | 룰렛 취소 시 예산 복구 | 당일만 복구 |
| PDP-6 | 예산 < 당첨금 처리 | 잔여 100p 미만이면 소진 처리 |
| PDP-7 | 유저 식별 방식 | 닉네임 = 유저 ID (자동 생성) |
| **PDP-8** | **역할 기반 접근 제어** | **로그인 Mocking 공유 + role별 API/화면 완전 분리. ADMIN↔USER 상호 접근 금지 (403)** |

---

정책 전체 확정 완료입니다. `docs/SPEC.md` 작성으로 넘어갈까요?

---

### 사용자:

응 넘어가자

---

### Claude 응답:

`docs/SPEC.md` 작성 완료했습니다.

**주요 포함 내용**:
- 확정된 PDP 1~8 정책 전체 반영
- 도메인 모델 7개 엔티티 정의 (User, DailyBudget, RouletteHistory, PointLedger, Product, Order, OrderPointUsage)
- API 명세 — 인증 1개 / 사용자 7개 / 어드민 10개 엔드포인트
- 에러 코드 12종 (구분 가능한 형태)
- 동시성 전략 (UNIQUE 제약, 조건부 UPDATE, SELECT FOR UPDATE)
- 화면 명세 (사용자 5화면, 어드민 5화면)
- 필수 동시성 테스트 7개 시나리오
- 엣지 케이스 처리 규칙 5건
- 6단계 구현 순서

다음 단계는 CLAUDE.md에서 정의한 순서대로 **Phase 1: 백엔드 코어 구현**입니다. 진행할까요?

---

### 사용자:

이 정보를 바탕으로 CLAUDE.md를 적절히 수정 및 업데이트해줘

---

### Claude 응답:

CLAUDE.md 업데이트 완료했습니다. 주요 변경사항:

**추가된 섹션**:
- **3. 확정 정책 (PDP)** — 8개 정책 전체 + PDP-8 상세 (역할 완전 분리)
- **7. API 경로 규칙** — 경로별 접근 권한, 응답 포맷, 에러 코드 12종
- **8. 엣지 케이스 처리 규칙** — 자정 요청, 예산 변경, 취소 충돌 등 5건
- **12. 필수 환경변수 목록** — `DATABASE_URL`, `ADMIN_NICKNAMES`, `JWT_SECRET`, `DAILY_BUDGET_DEFAULT`

**강화된 섹션**:
- **4. 동시성/정합성** — 재고 차감 패턴 추가, 트랜잭션 경계 테이블 추가
- **5. 시간 기준** — 자정 전후 처리 규칙 명시
- **11. 테스트** — 7개 시나리오를 테이블로 구조화, 커버리지 목표 추가

**업데이트된 섹션**:
- **14. 작업 순서** — 1~3단계 완료 표시, 현재 단계(백엔드 구현) 표기

다음 단계인 **Phase 1: 백엔드 구현**으로 진행할까요?

---

### 사용자:

/ccpp:handoff
지금까지 한 일을 HANDOFF.md에 인계문서로 남겨줘.
다음 세션이 바로 이어서 실행할 수 있게:

- 완료된 것
- 남은 것(우선순위)
- 결정한 정책/이유
- 현재 막힌 지점
- 다음에 실행할 정확한 첫 3개 액션
을 포함해줘.

---

### Claude 응답:

먼저 현재 프로젝트 상태를 확인하겠습니다.

`docs/HANDOFF.md` 인계 문서를 작성했습니다.

**요약:**
- **완료**: 기획/명세 단계 전체 (PDP 8개 확정, SPEC.md, CLAUDE.md)
- **다음**: Phase 1 백엔드 구현 — 프로젝트 초기화 → Entity 매핑 → Auth 구현 순서
- **막힌 지점**: 없음. 바로 구현 시작 가능

다음 세션에서 HANDOFF.md를 읽으면 즉시 Phase 1부터 이어갈 수 있습니다.

---

### 사용자:

LAST_LOG_CURSOR 이후의 프롬프트와 응답을
가공 없이 docs/PROMPT.md에 append 하고
커서를 현재 시점으로 업데이트해줘.

---

### Claude 응답:

LAST_LOG_CURSOR 이후의 대화를 append하고 커서를 업데이트했습니다.

<!-- LAST_LOG_CURSOR: 2026-02-05T18:10:00+09:00 -->